---
title: 暗号化の実践 (Cryptographic Practices)
---

### **説明**

スマートコントラクトにおける暗号化の実践は、認証、データ完全性、ランダム性といった機密性の高い操作が悪意のある操作から保護されることを確保します。安全な鍵管理、署名検証、適切な乱数生成は、不正アクセス、リプレイ攻撃、暗号化操作の脆弱性の悪用といった脆弱性を防ぐために不可欠です。

適切な暗号化の実践は、不正なトランザクション、予測可能な結果、セキュリティ侵害などの深刻な結果につながる可能性があります。

### **例: 不適切な署名検証**

```solidity
function verifySignature(address signer, bytes32 message, bytes memory signature) public pure returns (bool) {
    bytes32 messageHash = keccak256(abi.encodePacked(message));
    address recoveredSigner = ecrecover(messageHash, uint8(signature[64]), bytes32(signature[0]), bytes32(signature[32]));
    return recoveredSigner == signer;
}
```

この例では、署名が有効かどうかを確認せずに `ecrecover` 関数が使用されているため、署名の可鍛性や無効なデータリカバリなどの脆弱性につながる可能性があります。

### **影響**

- **不正アクセス**: 脆弱な暗号化手法は、攻撃者が署名を偽造したり、ユーザーになりすまして、コントラクト内で不正なアクションにつながる可能性があります。
- **再入攻撃**: 暗号化関数が外部呼び出しを検証するために使用されている場合、攻撃者は脆弱なロジックや不適切に実装されたロジックを悪用してコントラクトに再入する可能性があります。
- **結果の不正操作**: 予測可能または脆弱な乱数生成は、くじやゲーム系 dApps など、ランダム性に依存するシステムにおいて攻撃者が結果を不正操作できる可能性があります。
- **リプレイ攻撃**: 不十分な署名バリデーションは、署名されたメッセージがさまざまなコンテキストで再使用されるリプレイ攻撃につながり、攻撃者が意図しないアクションを実行できる可能性があります。

### **対策**

- **鍵管理**: 秘密鍵 (private key) が安全に保管され、コントラクトにハードコードされていないようにし、鍵管理にはハードウェアソリューションを使用します。
- **署名検証**: ノンスやハッシュ化されたメッセージを使用して署名の可鍛性を処理するなど、署名の妥当性の適切なチェックを実装します。
- **ランダム性**: Chainlink VRF (Verifiable Random Function) など、安全なエントロピーソースを使用して、ランダム性が不正操作されないようにします。
- **標準への準拠**: 署名の可鍛性やその他の脆弱性を防ぐために EIP-712 などの暗号化標準に準拠するようにします。
